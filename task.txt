Задача: Улучшить IncludeModulesPlugin, хочу чтобы был параметр в local.properties где бы указывался подпроект который только нужно компилировать и все подпроекты от которых он зависит
вместо того чтобы компилировать все, так вот параметр module="", если буде app то все что нужно только app модулю, если feature:games:xo:demo то только это


Дополнительная информация:

    # Введение

    При разработке такого крупного проекта как МБ, где количество модулей исчисляется в сотнях, можно столкнуться с рядом проблем:
    - длительное время синхронизации проекта;
    - длительное время конфигурации и сборки проекта.

    Причиной этих проблем, является то, что `gradle` выполняет больше тасок, чем необходимо для сборки конкретной фичи.<br/>
    Разрабатывая фичу, мы в основном меняем код в модуле фичи. Но запуская ее в основном проекте, `gradle` будет синхронизировать, конфигурировать и собирать **все модули** в проекте.<br/>
    Конечно есть инкрементальная компиляция, кэш конфигурации и сборки, благодаря чему при изменениях будет пересобрано минимальное количество модулей, но все же гораздо больше, чем необходимо для сборки самой фичи, так как будут пересобираться еще и те модули, которые зависят от самой фичи.<br/>
    А хотелось бы, чтобы можно было собрать фичу с минимальным количеством необходимых для нее модулей, запустить на девайсе и получить результат как можно быстрее.

    По мере того как проект растет все выше перечисленные проблемы только усугубляются.
    Вместо того, чтоб сфокусироваться над разработкой фичи и быстро получать обратную связь о внесенных изменениях, приходится тратить время на ожидание, пока соберется весь проект, что негативно отражается на скорости разработки проекта в целом.

    ## Зачем нужны демо приложения?

    Демо приложения позволяют разрабатывать и запускать фичу с минимально необходимым набором модулей, благодаря чему **уменьшается время конфигурации и сборки проекта**.<br/>
    Чем меньше модулей подключается к демо приложению, тем быстрее будет происходить сборка и тем быстрее можно будет получить обратную связь.

    :::tip
    Важно следить за тем, чтобы подключаемые фичи к демо приложению не зависели от большого количества модулей.
    Для контроля зависимостей можно использовать [плагин для подсчета количества модулей в зависимостях](/docs/development/gradle-stuff/plugins_help-tasks-plugin.md#projectdependenciescounttask) и [плагин для поиска неиспользуемых зависимостей](/docs/development/gradle-stuff/plugins_readme.md#rutinkoffmbpluginsdependency-analysis).

    Чтобы минимизировать количество модулей от которых зависит фича, необходимо строго следовать [правилам зависимостей](https://wiki.tcsbank.ru/pages/viewpage.action?pageId=1553811636).
    Если к демо приложению будет подключаться 500+ модулей, то разница в скорости сборки с МБ будет едва заметна.
    :::

    Помимо **конфигурации и сборки** есть еще **синхронизация проекта**(`sync`). Само по себе демо приложение не влияет на `sync`. На это влияет количество подключенных модулей в `settigns.gradle`.<br/>
    То есть, если создать демо приложение и не отключить из `settigns.gradle` все неиспользуемые модули, то время `sync` останется прежним, так как при добавлении какой-нибудь зависимости в `build.gradle` любого модуля каждый раз будет синхронизироваться весь проект.<br/>
    Но благодаря тому, что для демо приложения нужен минимальный набор модулей, все **неиспользуемые модули можно отключить**.

    :::tip
    Чтобы уменьшить время `sync`, необходимо в `local.properties` в параметре `ru.tinkoff.include-subprojects.roots` указать имя модуля демо приложения, например:
    `ru.tinkoff.include-subprojects.roots=:app-example-demo`. Благодаря этому, будут отключены все неиспользуемые модули из `settigns.gradle` и время `sync` значительно уменьшиться.
    :::

    ## Обратная связь
    Если есть вопросы по демо приложениям, пишите в канал [~mb-demo-app-android~](https://time.tinkoff.ru/tinkoff/channels/mb-demo-app-android)

Код в которой можно подсмотреть:
    abstract class IncludeSubprojectsPlugin : Plugin<Settings> {

        @get:Inject
        abstract val objectFactory: ObjectFactory

        /**
         * Directories that definitely do not contain subprojects and composite builds.
         */
        private val globalExcludes: List<String> = listOf(
            "**/build/**",
            "**/src/**",
            "**/.*/**",
        )

        private val logger: Logger = Logging.getLogger(IncludeSubprojectsPlugin::class.java)

        override fun apply(target: Settings) {
            val inclusionResult = measureInclusion(target)
            val resultLogger = InclusionResultLogger(logger = logger, projectName = target.rootProject.name)
            resultLogger.logResults(tag = TAG, inclusionResult = inclusionResult)
        }

        private fun measureInclusion(target: Settings): InclusionResult {
            val rootPaths = GradleModulePathResolver(target = target, objectFactory = objectFactory).resolveModulePaths()
            val subprojectsByPath = subprojectsByPath(target.rootDir)
            val includedSubprojectsCount: Int
            val includedAllSubprojects: Boolean
            val measuredTimeMillis = measureTimeMillis {
                includedSubprojectsCount = if (rootPaths.isEmpty()) {
                    includedAllSubprojects = true
                    includeSubprojects(
                        target = target,
                        subprojectsByPath = subprojectsByPath
                    )
                } else {
                    includedAllSubprojects = false
                    includeSubprojectsForRootPaths(
                        target = target,
                        subprojectsByPath = subprojectsByPath,
                        rootPaths = rootPaths
                    )
                }
            }
            return InclusionResult(
                subprojectsCount = subprojectsByPath.size,
                includedSubprojectsCount = includedSubprojectsCount,
                includedAllSubprojects = includedAllSubprojects,
                rootPaths = rootPaths,
                measuredTimeMillis = measuredTimeMillis
            )
        }

        /**
         * @return number of included projects.
         */
        private fun includeSubprojects(
            target: Settings,
            subprojectsByPath: Map<String, ProjectDetails>,
        ): Int = subprojectsByPath.onEach { (path, details) ->
            target.include(path)
            target.project(path).projectDir = details.dir
        }.size

        /**
         * @return number of included projects.
         */
        private fun includeSubprojectsForRootPaths(
            target: Settings,
            subprojectsByPath: Map<String, ProjectDetails>,
            rootPaths: List<String>,
        ): Int {
            var includedSubprojectsCount = 0
            val availableSubprojectsByPath = subprojectsByPath.toMutableMap()
            rootPaths.forEach { rootPath ->
                val rootSubproject = subprojectsByPath[rootPath] ?: error("Root path '$rootPath' not found in subprojects.")
                if (availableSubprojectsByPath.containsKey(rootSubproject.path)) {
                    availableSubprojectsByPath.remove(rootSubproject.path)
                    val subprojectsToCheck = ArrayDeque<ProjectDetails>()
                    subprojectsToCheck.add(rootSubproject)
                    do {
                        subprojectsToCheck.removeFirst().also { currentSubproject ->
                            target.include(currentSubproject.path)
                            target.project(currentSubproject.path).projectDir = currentSubproject.dir
                            includedSubprojectsCount += 1
                            currentSubproject.filterDependentProjects(
                                projects = availableSubprojectsByPath.values.toList()
                            ).forEach { dependencyProject ->
                                subprojectsToCheck.add(dependencyProject)
                                availableSubprojectsByPath.remove(dependencyProject.path)
                            }
                        }
                    } while (subprojectsToCheck.isNotEmpty())
                }
            }
            return includedSubprojectsCount
        }

        private fun subprojectsByPath(rootDir: File): Map<String, ProjectDetails> {
            val compositeBuildsDirs = compositeBuildsDirs(rootDir = rootDir)
            val subprojectsBuildGradleFiles = objectFactory.fileTree().from(rootDir).apply {
                include("**/build.gradle*")
                exclude(
                    compositeBuildsDirs.mapNotNull { compositeBuildDir ->
                        compositeBuildDir.relativeToOrNull(rootDir)?.let { compositeBuildRelativeDir ->
                            "${compositeBuildRelativeDir.path}/**"
                        }
                    }
                        .plus(globalExcludes.plus("build.gradle*"))
                )
            }.files
            return subprojectsBuildGradleFiles.mapNotNull { buildGradleFile ->
                buildGradleFile.parentFile?.let { subprojectDir ->
                    ProjectDetails(
                        path = ":${subprojectDir.name}",
                        dir = subprojectDir,
                        buildScript = buildGradleFile,
                    )
                }
            }.associateBy { it.path }
        }

        private fun compositeBuildsDirs(rootDir: File): List<File> {
            return objectFactory.fileTree().from(rootDir).apply {
                include("**/settings.gradle*")
                exclude(globalExcludes.plus("settings.gradle*"))
            }.files.mapNotNull { settingsGradleFile -> settingsGradleFile.parentFile }
        }
    }

